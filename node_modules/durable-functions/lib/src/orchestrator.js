"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require("debug");
const classes_1 = require("./classes");
const orchestratorstate_1 = require("./orchestratorstate");
const continueasnewaction_1 = require("./continueasnewaction");
const log = debug("orchestrator");
class Orchestrator {
    constructor(fn) {
        this.fn = fn;
    }
    listen() {
        return this.handle.bind(this);
    }
    handle(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = context.bindings.context.history;
            const input = context.bindings.context.input;
            context.df = {};
            context.df.instanceId = context.bindings.context.instanceId;
            context.df.isReplaying = context.bindings.context.isReplaying;
            context.df.parentInstanceId = context.bindings.context.parentInstanceId;
            context.df.callActivity = this.callActivity.bind(this, state);
            context.df.callActivityWithRetry = this.callActivityWithRetry.bind(this, state);
            context.df.callSubOrchestrator = this.callSubOrchestrator.bind(this, state);
            context.df.callSubOrchestratorWithRetry = this.callSubOrchestratorWithRetry.bind(this, state);
            context.df.continueAsNew = this.continueAsNew.bind(this, state);
            context.df.createTimer = this.createTimer.bind(this, state);
            context.df.getInput = this.getInput.bind(this, input);
            context.df.setCustomStatus = this.setCustomStatus.bind(this);
            context.df.waitForExternalEvent = this.waitForExternalEvent.bind(this, state);
            context.df.Task = {};
            context.df.Task.all = this.all.bind(this, state);
            context.df.Task.any = this.any.bind(this, state);
            let decisionStartedEvent = state.find((e) => (e.EventType === classes_1.HistoryEventType.OrchestratorStarted));
            if (decisionStartedEvent) {
                context.df.currentUtcDateTime = decisionStartedEvent.Timestamp;
            }
            const gen = this.fn(context);
            const actions = [];
            let partialResult;
            while (true) {
                try {
                    const g = gen.next(partialResult ? partialResult.result : undefined);
                    if (g.done) {
                        log("Iterator is done");
                        this.finish(context, state, actions, true, g.value);
                        return;
                    }
                    partialResult = g.value;
                    if (partialResult instanceof classes_1.Task && partialResult.action) {
                        actions.push([partialResult.action]);
                    }
                    else if (partialResult instanceof classes_1.TaskSet && partialResult.actions) {
                        actions.push(partialResult.actions);
                    }
                    if (this.shouldFinish(partialResult)) {
                        this.finish(context, state, actions);
                        return;
                    }
                    else if (partialResult instanceof classes_1.Task && partialResult.isFaulted) {
                        gen.throw(partialResult.exception);
                    }
                    decisionStartedEvent = state.find((e) => e.EventType === classes_1.HistoryEventType.OrchestratorStarted &&
                        e.Timestamp > decisionStartedEvent.Timestamp);
                    context.df.currentUtcDateTime = decisionStartedEvent.Timestamp;
                }
                catch (error) {
                    this.error(context, actions, error);
                    return;
                }
            }
        });
    }
    callActivity(state, name, input) {
        const newAction = new classes_1.CallActivityAction(name, input);
        const taskScheduled = this.findTaskScheduled(state, name);
        const taskCompleted = this.findTaskCompleted(state, taskScheduled);
        const taskFailed = this.findTaskFailed(state, taskScheduled);
        this.setProcessed([taskScheduled, taskCompleted, taskFailed]);
        if (taskCompleted) {
            const result = this.parseHistoryEvent(taskCompleted);
            return new classes_1.Task(true, false, newAction, result, taskCompleted.Timestamp, taskCompleted.TaskScheduledId);
        }
        else if (taskFailed) {
            return new classes_1.Task(true, true, newAction, taskFailed.Reason, taskFailed.Timestamp, taskFailed.TaskScheduledId, new Error(taskFailed.Reason));
        }
        else {
            return new classes_1.Task(false, false, newAction);
        }
    }
    callActivityWithRetry(state, name, retryOptions, input) {
        const newAction = new classes_1.CallActivityWithRetryAction(name, retryOptions, input);
        for (let attempt = 1; attempt <= retryOptions.maxNumberOfAttempts; attempt++) {
            const taskScheduled = this.findTaskScheduled(state, name);
            const taskCompleted = this.findTaskCompleted(state, taskScheduled);
            const taskFailed = this.findTaskFailed(state, taskScheduled);
            const taskRetryTimer = this.findRetryTimer(state, taskFailed);
            const taskRetryTimerFired = this.findTimerFired(state, taskRetryTimer);
            this.setProcessed([taskScheduled, taskCompleted, taskFailed, taskRetryTimer, taskRetryTimerFired]);
            if (!taskScheduled) {
                break;
            }
            if (taskCompleted) {
                const result = this.parseHistoryEvent(taskCompleted);
                return new classes_1.Task(true, false, newAction, result, taskCompleted.Timestamp, taskCompleted.TaskScheduledId);
            }
            else if (taskFailed && taskRetryTimer && attempt >= retryOptions.maxNumberOfAttempts) {
                return new classes_1.Task(true, true, newAction, taskFailed.Reason, taskFailed.Timestamp, taskFailed.TaskScheduledId, new Error(taskFailed.Reason));
            }
        }
        return new classes_1.Task(false, false, newAction);
    }
    callSubOrchestrator(state, name, input, instanceId) {
        const newAction = new classes_1.CallSubOrchestratorAction(name, instanceId, input);
        const subOrchestratorCreated = this.findSubOrchestrationInstanceCreated(state, name, instanceId);
        const subOrchestratorCompleted = this.findSubOrchestrationInstanceCompleted(state, subOrchestratorCreated);
        const subOrchestratorFailed = this.findSubOrchestrationInstanceFailed(state, subOrchestratorCreated);
        this.setProcessed([subOrchestratorCreated, subOrchestratorCompleted]);
        if (subOrchestratorCompleted) {
            const result = this.parseHistoryEvent(subOrchestratorCompleted);
            return new classes_1.Task(true, false, newAction, result, subOrchestratorCompleted.Timestamp, subOrchestratorCompleted.TaskScheduledId);
        }
        else if (subOrchestratorFailed) {
            return new classes_1.Task(true, true, newAction, subOrchestratorFailed.Reason, subOrchestratorFailed.Timestamp, subOrchestratorFailed.TaskScheduledId, new Error(subOrchestratorFailed.Reason));
        }
        else {
            return new classes_1.Task(false, false, newAction);
        }
    }
    callSubOrchestratorWithRetry(state, name, retryOptions, input, instanceId) {
        const newAction = new classes_1.CallSubOrchestratorWithRetryAction(name, retryOptions, input, instanceId);
        for (let attempt = 1; attempt <= retryOptions.maxNumberOfAttempts; attempt++) {
            const subOrchestratorCreated = this.findSubOrchestrationInstanceCreated(state, name, instanceId);
            const subOrchestratorCompleted = this.findSubOrchestrationInstanceCompleted(state, subOrchestratorCreated);
            const subOrchestratorFailed = this.findSubOrchestrationInstanceFailed(state, subOrchestratorCreated);
            const retryTimer = this.findRetryTimer(state, subOrchestratorFailed);
            const retryTimerFired = this.findTimerFired(state, retryTimer);
            this.setProcessed([
                subOrchestratorCreated,
                subOrchestratorCompleted,
                subOrchestratorFailed,
                retryTimer,
                retryTimerFired,
            ]);
            if (!subOrchestratorCreated) {
                break;
            }
            if (subOrchestratorCompleted) {
                const result = this.parseHistoryEvent(subOrchestratorCompleted);
                return new classes_1.Task(true, false, newAction, result, subOrchestratorCompleted.Timestamp, subOrchestratorCompleted.TaskScheduledId);
            }
            else if (subOrchestratorFailed && retryTimer && attempt >= retryOptions.maxNumberOfAttempts) {
                return new classes_1.Task(true, true, newAction, subOrchestratorFailed.Reason, subOrchestratorFailed.Timestamp, subOrchestratorFailed.TaskScheduledId, new Error(subOrchestratorFailed.Reason));
            }
        }
        return new classes_1.Task(false, false, newAction);
    }
    continueAsNew(state, input) {
        const newAction = new continueasnewaction_1.ContinueAsNewAction(input);
        return new classes_1.Task(false, false, newAction);
    }
    createTimer(state, fireAt) {
        const newAction = new classes_1.CreateTimerAction(fireAt);
        const timerCreated = this.findTimerCreated(state, fireAt);
        const timerFired = this.findTimerFired(state, timerCreated);
        this.setProcessed([timerCreated, timerFired]);
        if (timerFired) {
            return new classes_1.TimerTask(true, false, newAction, undefined, timerFired.Timestamp, timerFired.TimerId);
        }
        else {
            return new classes_1.TimerTask(false, false, newAction);
        }
    }
    getInput(input) {
        return input;
    }
    setCustomStatus(customStatusObject) {
        this.customStatus = customStatusObject;
    }
    waitForExternalEvent(state, name) {
        const newAction = new classes_1.WaitForExternalEventAction(name);
        const eventRaised = this.findEventRaised(state, name);
        this.setProcessed([eventRaised]);
        if (eventRaised) {
            const result = this.parseHistoryEvent(eventRaised);
            return new classes_1.Task(true, false, newAction, result, eventRaised.Timestamp, eventRaised.EventId);
        }
        else {
            return new classes_1.Task(false, false, newAction);
        }
    }
    all(state, tasks) {
        const allActions = tasks.reduce((accumulator, currentValue) => {
            return [...accumulator, currentValue.action];
        }, []);
        const isCompleted = tasks.every((r) => r.isCompleted);
        if (isCompleted) {
            const results = tasks.reduce((acc, t) => {
                return [...acc, t.result];
            }, []);
            return new classes_1.TaskSet(isCompleted, allActions, results);
        }
        else {
            return new classes_1.TaskSet(isCompleted, allActions);
        }
    }
    any(state, tasks) {
        const allActions = tasks.reduce((accumulator, currentValue) => {
            return [...accumulator, currentValue.action];
        }, []);
        const completedTasks = tasks
            .filter((t) => t.isCompleted)
            .sort((a, b) => {
            if (a.timestamp > b.timestamp) {
                return 1;
            }
            if (a.timestamp < b.timestamp) {
                return -1;
            }
            return 0;
        });
        const firstCompleted = completedTasks[0];
        if (firstCompleted) {
            return new classes_1.TaskSet(true, allActions, firstCompleted);
        }
        else {
            return new classes_1.TaskSet(false, allActions);
        }
    }
    parseHistoryEvent(directiveResult) {
        let parsedDirectiveResult;
        switch (directiveResult.EventType) {
            case (classes_1.HistoryEventType.EventRaised):
                parsedDirectiveResult = JSON.parse(directiveResult.Input);
                break;
            case (classes_1.HistoryEventType.SubOrchestrationInstanceCompleted):
                parsedDirectiveResult = JSON.parse(directiveResult.Result);
                break;
            case (classes_1.HistoryEventType.TaskCompleted):
                parsedDirectiveResult = JSON.parse(directiveResult.Result);
                break;
            default:
                break;
        }
        return parsedDirectiveResult;
    }
    finish(context, state, actions, isDone = false, output) {
        log("Finish called");
        const returnValue = new orchestratorstate_1.OrchestratorState(isDone, actions, output, this.customStatus);
        context.done(null, returnValue);
    }
    error(context, actions, err) {
        log(`Error: ${err}`);
        const returnValue = new orchestratorstate_1.OrchestratorState(false, actions, undefined, this.customStatus);
        context.done(err, undefined);
    }
    findEventRaised(state, eventName) {
        return eventName ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.EventRaised
                    && val.Name === eventName
                    && !val.IsProcessed;
            })[0]
            : undefined;
    }
    findRetryTimer(state, failedTask) {
        return failedTask ?
            state.filter((val, index, array) => {
                const failedTaskIndex = array.indexOf(failedTask);
                return val.EventType === classes_1.HistoryEventType.TimerCreated
                    && index === (failedTaskIndex + 1);
            })[0]
            : undefined;
    }
    findSubOrchestrationInstanceCreated(state, name, instanceId) {
        return name ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCreated
                    && val.Name === name
                    && val.InstanceId === instanceId
                    && !val.IsProcessed;
            })[0]
            : undefined;
    }
    findSubOrchestrationInstanceCompleted(state, createdSubOrchInstance) {
        return createdSubOrchInstance ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCompleted
                    && val.TaskScheduledId === createdSubOrchInstance.EventId;
            })[0]
            : undefined;
    }
    findSubOrchestrationInstanceFailed(state, createdSubOrchInstance) {
        return createdSubOrchInstance ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceFailed
                    && val.TaskScheduledId === createdSubOrchInstance.EventId;
            })[0]
            : undefined;
    }
    findTaskScheduled(state, name) {
        return name ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.TaskScheduled
                    && val.Name === name
                    && !val.IsProcessed;
            })[0]
            : undefined;
    }
    findTaskCompleted(state, scheduledTask) {
        return scheduledTask ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.TaskCompleted
                    && val.TaskScheduledId === scheduledTask.EventId;
            })[0]
            : undefined;
    }
    findTaskFailed(state, scheduledTask) {
        return scheduledTask ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.TaskFailed
                    && val.TaskScheduledId === scheduledTask.EventId;
            })[0]
            : undefined;
    }
    findTimerCreated(state, fireAt) {
        return fireAt ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.TimerCreated
                    && new Date(val.FireAt).getTime() === fireAt.getTime();
            })[0]
            : undefined;
    }
    findTimerFired(state, createdTimer) {
        return createdTimer ?
            state.filter((val) => {
                return val.EventType === classes_1.HistoryEventType.TimerFired
                    && val.TimerId === createdTimer.EventId;
            })[0]
            : undefined;
    }
    setProcessed(events) {
        events.map((val) => {
            if (val) {
                val.IsProcessed = true;
            }
        });
    }
    shouldFinish(result) {
        return !result.isCompleted || result instanceof classes_1.Task && result.action instanceof continueasnewaction_1.ContinueAsNewAction;
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=orchestrator.js.map